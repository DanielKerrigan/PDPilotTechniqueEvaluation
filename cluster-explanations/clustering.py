import altair as alt
import numpy as np
import pandas as pd


def create_dataset(num_instances, seed):
    """
    Create a synthetic dataset where x2 interacts with x3 and x4.
    This dataset is based on Equation 3 from the 2015 paper by
    Goldstein et al. that introduced ICE plots.
    """

    rng = np.random.default_rng(seed=seed)

    df = pd.DataFrame(
        {
            "x1": rng.uniform(low=-1, high=1, size=(num_instances,)),
            "x2": rng.uniform(low=-1, high=1, size=(num_instances,)),
            "x3": rng.uniform(low=-1, high=1, size=(num_instances,)),
            "x4": rng.uniform(low=-1, high=1, size=(num_instances,)),
        }
    )

    df["y"] = (
        (0.2 * df["x1"])
        - (5 * df["x2"])
        + np.where((df["x3"] >= 0) & (df["x4"] >= (1 / 3)), 10 * df["x2"], 0)
        + rng.normal(loc=0, scale=1, size=(num_instances,))
    )

    return df


def plot_vine_clusters(data, feature, title=None, show_precision_recall=False):
    """
    Plot the clustered ICE plots generated by VINE in a style similar to PDPilot.
    """

    light_colors = [
        "#a6cee3",
        "#fdbf6f",
        "#b2df8a",
        "#fb9a99",
        "#cab2d6",
        "#FFB3F2",
        "#D4906D",
    ]

    dark_colors = [
        "#1f78b4",
        "#ff7f00",
        "#33a02c",
        "#e31a1c",
        "#6a3d9a",
        "#f781bf",
        "#B15928",
    ]

    feature_data = data["features"][feature]

    # data and chart for the black PDP line that we will add to each plot

    resolution = len(feature_data["x_values"])

    assert resolution == len(feature_data["pdp_line"])

    df_pdp = pd.DataFrame(
        {
            "x": feature_data["x_values"],
            "y": feature_data["pdp_line"],
        }
    )

    pdp_chart = alt.Chart(df_pdp).mark_line(color="black").encode(x="x", y="y")

    # loop over clusters and concatenate to chart

    chart = alt.hconcat()

    for cluster_id, cluster in enumerate(feature_data["clusters"]):
        xs = []
        ys = []
        instances = []

        # loop over the ICE lines in this cluster to create a dataframe for them
        for line_id, curve in enumerate(cluster["individual_ice_curves"]):
            assert resolution == len(curve)
            xs.extend(feature_data["x_values"])
            ys.extend(curve)
            instances.extend([line_id] * resolution)

        df_ice = pd.DataFrame({"x": xs, "y": ys, "instance": instances})

        # chart for individual ICE lines
        ice_chart = (
            alt.Chart(df_ice)
            .mark_line(opacity=0.25, color=light_colors[cluster_id])
            .encode(
                x=alt.X("x").title(feature).axis(grid=False),
                y=alt.Y("y").title("Mean centered prediction").axis(grid=False),
                detail="instance",
            )
        )

        # data and chart for cluster center

        assert resolution == len(cluster["line"])

        df_cluster_center = pd.DataFrame(
            {
                "x": feature_data["x_values"],
                "y": cluster["line"],
            }
        )

        center_chart = (
            alt.Chart(df_cluster_center)
            .mark_line(color=dark_colors[cluster_id], strokeWidth=2)
            .encode(x="x", y="y")
        )

        # layer the three charts on top of each other and add a title

        cluster_title = f"{cluster['split_feature']} {cluster['split_direction']} {cluster['split_val']}"
        cluster_subtitle = [
            f"Rule accuracy = {cluster['accuracy']}%, Cluster size = {cluster['cluster_size']} instances",
        ]

        if show_precision_recall:
            cluster_subtitle.append(
                f"Precision = {cluster['precision']}, Recall = {cluster['recall']}"
            )

        cluster_chart = (ice_chart + pdp_chart + center_chart).properties(
            title=alt.Title(
                cluster_title,
                subtitle=cluster_subtitle,
                anchor="start",
                frame="group",
            )
        )

        chart |= cluster_chart

    chart = chart.resolve_scale(y="shared")

    if title:
        chart = chart.properties(title=alt.Title(title, anchor="middle"))

    return chart
